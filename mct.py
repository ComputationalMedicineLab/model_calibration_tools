"""
Model Calibration Tools
"""
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
from sklearn.neighbors import KernelDensity


def histograms(probs, actual, bins=100):
    """
    Calculates two histograms over [0, 1] by partitioning `probs` with `actual`
    and sorting each partition into `bins` sub-intervals.
    """
    actual = actual.astype(np.bool)
    edges, step = np.linspace(0., 1., bins, retstep=True, endpoint=False)
    idx = np.digitize(probs, edges) - 1
    top = np.bincount(idx, weights=actual, minlength=bins)
    bot = np.bincount(idx, weights=(~actual), minlength=bins)
    return top, bot, edges, step


def kde_calibration_curve(probs,
                          actual,
                          resolution=0.01,
                          kernel='gaussian',
                          bandwidth=0.1):
    """
    Generate a calibration curve smoothed via KDE.
    """

    x_min = max((0, np.amin(probs) - resolution))
    x_max = min((1, np.amax(probs) + resolution))

    x_values = np.arange(x_min, x_max, step=resolution)
    # Calculate the curve for actual values
    kde = KernelDensity(kernel=kernel, bandwidth=bandwidth)
    positives = probs[actual == 1]
    kde.fit(positives.reshape(-1, 1))
    # `pos_density` has been normalized so that the area under np.exp(pos_density) is
    # equal to one, but since we're using this to generate another curve, we
    # need to de-normalize the curve
    pos_density = kde.score_samples(x_values.reshape(-1, 1))
    pos_intensity = np.exp(pos_density) * len(positives)

    # Calculate the density for _all_ values
    kde = KernelDensity(kernel=kernel, bandwidth=bandwidth)
    kde.fit(probs.reshape(-1, 1))
    all_density = kde.score_samples(x_values.reshape(-1, 1))
    # See above note about density
    all_intensity = np.exp(all_density) * len(probs)

    # Now the estimated fraction is the ratio of positives to all
    return (x_values, pos_intensity / all_intensity, pos_intensity,
            all_intensity)


def compute_ici(x_values, calibration, all_intensity):
    ici = np.sum(all_intensity * np.abs(calibration - x_values)) / \
        np.sum(all_intensity)
    return ici


def plot_histograms(top, bot, edges, resolution, *, ax=None):
    """
    Plots the two histograms generated by ``histograms``; the histogram of actual negatives
    is plotted underneath the x axis while the histogram of actual positives is plotted
    above.
    """
    if ax is None:
        ax = plt.gca()

    ax.hlines(y=0,
              xmin=0,
              xmax=1,
              linestyle='dashed',
              color='black',
              alpha=0.2)
    ax.bar(edges, top, width=resolution)
    ax.bar(edges, -bot, width=resolution)
    # Set some sensible defaults - these can be overridden after the fact,
    # since we return the axes object
    ax.set_xlim((-0.05, 1.05))
    ax.set_xlabel('Predicted Probability')
    height = max(abs(x) for x in ax.get_ylim())
    ax.set_ylim((-height, height))
    ax.set_ylabel('Count')
    return ax


def plot_calibration_curve(x_values,
                           calibration,
                           pos_intensity=None,
                           all_intensity=None,
                           *,
                           ici=True,
                           label=None,
                           ax=None):
    """
    Plots a calibration curve.
    """
    inc_sources = pos_intensity is not None and all_intensity is not None

    if ax is None:
        ax = plt.gca()

    ax.set_aspect('equal')
    limits = (-0.05, 1.05)
    ax.set_ylim(limits)
    ax.set_xlim(limits)

    estimate_label = 'Estimated Calibration'
    if ici:
        ici = compute_ici(x_values, calibration, all_intensity)
        estimate_label = f'Estimated Calibration (ICI {ici:0.3f})'

    lines, unit = [], (0, 1)
    lines.extend(ax.plot(unit, unit, 'k:', label='Perfect Calibration'))
    lines.extend(ax.plot(x_values, calibration, label=estimate_label))

    if inc_sources:
        # We normalize the sources to the interval 0, 1 so the plots will align
        # perfectly
        pos_intensity /= all_intensity.max()
        all_intensity /= all_intensity.max()
        lines.extend(
            ax.plot(x_values,
                    pos_intensity,
                    'C1',
                    alpha=0.4,
                    label='Positive Intensity'))
        lines.extend(
            ax.plot(x_values,
                    all_intensity,
                    'C2',
                    alpha=0.4,
                    label='All Intensity'))
    ax.legend(lines, [li.get_label() for li in lines], loc='best')
    ax.set_xlabel('Predicted Probability')
    ax.set_ylabel('Actual Probability')
    ax.yaxis.set_major_formatter(mpl.ticker.PercentFormatter(xmax=1.0))
    if label is not None:
        ax.set_title(f'{label}')

    return ax


def display_calibration(probs,
                        actual,
                        *,
                        figure=None,
                        bins=100,
                        label=None,
                        ici=True,
                        kernel='gaussian',
                        bandwidth=0.1,
                        include_intensities=False):
    """
    Generates and returns a matplotlib figure with two axes containing the
    model's kde-smoothed calibration curve and histograms.
    """
    resolution = 1.0 / bins

    if figure is None:
        figure = plt.gcf()
    ax1, ax2 = figure.subplots(
        nrows=2,
        ncols=1,
        sharex=True,
        gridspec_kw=dict(height_ratios=(3, 1)),
    )
    x_values, calibration, pos_intensity, all_intensity = kde_calibration_curve(
        probs,
        actual,
        resolution=resolution,
        kernel=kernel,
        bandwidth=bandwidth)

    ax1 = plot_calibration_curve(
        x_values,
        calibration,
        pos_intensity=pos_intensity if include_intensities else None,
        all_intensity=all_intensity,
        label=label,
        ax=ax1)
    ax1.set_xlabel('')
    ax2 = plot_histograms(*histograms(probs, actual, bins=bins), ax=ax2)
    ax2.set_box_aspect(1. / 3.)
    ax1.xaxis.set_ticks_position('none')
    figure.tight_layout()
    return figure
